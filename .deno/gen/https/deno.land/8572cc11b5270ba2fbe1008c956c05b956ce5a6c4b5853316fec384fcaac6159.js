/* eslint-disable @typescript-eslint/ban-ts-comment */ import { METHOD_NAME_ALL, METHODS, UnsupportedPathError } from '../../router.ts';
import { checkOptionalParameter } from '../../utils/url.ts';
import { PATH_ERROR } from './node.ts';
import { Trie } from './trie.ts';
const methodNames = [
    METHOD_NAME_ALL,
    ...METHODS
].map((method)=>method.toUpperCase());
const emptyParam = {};
// eslint-disable-next-line @typescript-eslint/no-explicit-any
const nullMatcher = [
    /^$/,
    [],
    {}
];
let wildcardRegExpCache = {};
function buildWildcardRegExp(path) {
    return wildcardRegExpCache[path] ??= new RegExp(path === '*' ? '' : `^${path.replace(/\/\*/, '(?:|/.*)')}$`);
}
function clearWildcardRegExpCache() {
    wildcardRegExpCache = {};
}
function buildMatcherFromPreprocessedRoutes(routes) {
    const trie = new Trie();
    const handlers = [];
    if (routes.length === 0) {
        return nullMatcher;
    }
    routes = routes.sort(([a], [b])=>a.length - b.length);
    const staticMap = {};
    for(let i = 0, j = -1, len = routes.length; i < len; i++){
        const path = routes[i][0];
        let pathErrorCheckOnly = false;
        if (!/\*|\/:/.test(path)) {
            pathErrorCheckOnly = true;
            staticMap[routes[i][0]] = {
                handlers: routes[i][1],
                params: emptyParam
            };
        } else {
            j++;
        }
        let paramMap;
        try {
            paramMap = trie.insert(path, j, pathErrorCheckOnly);
        } catch (e) {
            throw e === PATH_ERROR ? new UnsupportedPathError(path) : e;
        }
        if (pathErrorCheckOnly) {
            continue;
        }
        handlers[j] = paramMap.length === 0 ? [
            {
                handlers: routes[i][1],
                params: emptyParam
            },
            null
        ] : [
            routes[i][1],
            paramMap
        ];
    }
    const [regexp, indexReplacementMap, paramReplacementMap] = trie.buildRegExp();
    for(let i1 = 0, len1 = handlers.length; i1 < len1; i1++){
        const paramMap1 = handlers[i1][1];
        if (paramMap1) {
            for(let j1 = 0, len2 = paramMap1.length; j1 < len2; j1++){
                paramMap1[j1][1] = paramReplacementMap[paramMap1[j1][1]];
            }
        }
    }
    const handlerMap = [];
    // using `in` because indexReplacementMap is a sparse array
    for(const i2 in indexReplacementMap){
        handlerMap[i2] = handlers[indexReplacementMap[i2]];
    }
    return [
        regexp,
        handlerMap,
        staticMap
    ];
}
function findMiddleware(middleware, path) {
    if (!middleware) {
        return undefined;
    }
    for (const k of Object.keys(middleware).sort((a, b)=>b.length - a.length)){
        if (buildWildcardRegExp(k).test(path)) {
            return [
                ...middleware[k]
            ];
        }
    }
    return undefined;
}
export class RegExpRouter {
    middleware;
    routes;
    constructor(){
        this.middleware = {
            [METHOD_NAME_ALL]: {}
        };
        this.routes = {
            [METHOD_NAME_ALL]: {}
        };
    }
    add(method, path, handler) {
        const { middleware , routes  } = this;
        if (!middleware || !routes) {
            throw new Error('Can not add a route since the matcher is already built.');
        }
        if (!methodNames.includes(method)) methodNames.push(method);
        if (!middleware[method]) {
            [
                middleware,
                routes
            ].forEach((handlerMap)=>{
                handlerMap[method] = {};
                Object.keys(handlerMap[METHOD_NAME_ALL]).forEach((p)=>{
                    handlerMap[method][p] = [
                        ...handlerMap[METHOD_NAME_ALL][p]
                    ];
                });
            });
        }
        if (path === '/*') {
            path = '*';
        }
        if (/\*$/.test(path)) {
            const re = buildWildcardRegExp(path);
            if (method === METHOD_NAME_ALL) {
                Object.keys(middleware).forEach((m)=>{
                    middleware[m][path] ||= findMiddleware(middleware[m], path) || findMiddleware(middleware[METHOD_NAME_ALL], path) || [];
                });
            } else {
                middleware[method][path] ||= findMiddleware(middleware[method], path) || findMiddleware(middleware[METHOD_NAME_ALL], path) || [];
            }
            Object.keys(middleware).forEach((m)=>{
                if (method === METHOD_NAME_ALL || method === m) {
                    Object.keys(middleware[m]).forEach((p)=>{
                        re.test(p) && middleware[m][p].push(handler);
                    });
                }
            });
            Object.keys(routes).forEach((m)=>{
                if (method === METHOD_NAME_ALL || method === m) {
                    Object.keys(routes[m]).forEach((p)=>re.test(p) && routes[m][p].push(handler));
                }
            });
            return;
        }
        const paths = checkOptionalParameter(path) || [
            path
        ];
        for(let i = 0, len = paths.length; i < len; i++){
            const path1 = paths[i];
            Object.keys(routes).forEach((m)=>{
                if (method === METHOD_NAME_ALL || method === m) {
                    routes[m][path1] ||= [
                        ...findMiddleware(middleware[m], path1) || findMiddleware(middleware[METHOD_NAME_ALL], path1) || []
                    ];
                    routes[m][path1].push(handler);
                }
            });
        }
    }
    match(method, path) {
        clearWildcardRegExpCache() // no longer used.
        ;
        const matchers = this.buildAllMatchers();
        this.match = (method, path)=>{
            const matcher = matchers[method];
            const staticMatch = matcher[2][path];
            if (staticMatch) {
                return staticMatch;
            }
            const match = path.match(matcher[0]);
            if (!match) {
                return null;
            }
            const index = match.indexOf('', 1);
            const [handlers, paramMap] = matcher[1][index];
            if (!paramMap) {
                return handlers;
            }
            const params = {};
            for(let i = 0, len = paramMap.length; i < len; i++){
                params[paramMap[i][0]] = match[paramMap[i][1]];
            }
            return {
                handlers,
                params
            };
        };
        return this.match(method, path);
    }
    buildAllMatchers() {
        const matchers = {};
        methodNames.forEach((method)=>{
            matchers[method] = this.buildMatcher(method) || matchers[METHOD_NAME_ALL];
        });
        // Release cache
        this.middleware = this.routes = undefined;
        return matchers;
    }
    buildMatcher(method) {
        const routes = [];
        let hasOwnRoute = method === METHOD_NAME_ALL;
        [
            this.middleware,
            this.routes
        ].forEach((r)=>{
            const ownRoute = r[method] ? Object.keys(r[method]).map((path)=>[
                    path,
                    r[method][path]
                ]) : [];
            if (ownRoute.length !== 0) {
                hasOwnRoute ||= true;
                routes.push(...ownRoute);
            } else if (method !== METHOD_NAME_ALL) {
                routes.push(...Object.keys(r[METHOD_NAME_ALL]).map((path)=>[
                        path,
                        r[METHOD_NAME_ALL][path]
                    ]));
            }
        });
        if (!hasOwnRoute) {
            return null;
        } else {
            return buildMatcherFromPreprocessedRoutes(routes);
        }
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImh0dHBzOi8vZGVuby5sYW5kL3gvaG9ub0B2My4xLjYvcm91dGVyL3JlZy1leHAtcm91dGVyL3JvdXRlci50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvYmFuLXRzLWNvbW1lbnQgKi9cbmltcG9ydCB0eXBlIHsgUm91dGVyLCBSZXN1bHQgfSBmcm9tICcuLi8uLi9yb3V0ZXIudHMnXG5pbXBvcnQgeyBNRVRIT0RfTkFNRV9BTEwsIE1FVEhPRFMsIFVuc3VwcG9ydGVkUGF0aEVycm9yIH0gZnJvbSAnLi4vLi4vcm91dGVyLnRzJ1xuaW1wb3J0IHsgY2hlY2tPcHRpb25hbFBhcmFtZXRlciB9IGZyb20gJy4uLy4uL3V0aWxzL3VybC50cydcbmltcG9ydCB7IFBBVEhfRVJST1IgfSBmcm9tICcuL25vZGUudHMnXG5pbXBvcnQgdHlwZSB7IFBhcmFtTWFwIH0gZnJvbSAnLi90cmllLnRzJ1xuaW1wb3J0IHsgVHJpZSB9IGZyb20gJy4vdHJpZS50cydcblxuY29uc3QgbWV0aG9kTmFtZXMgPSBbTUVUSE9EX05BTUVfQUxMLCAuLi5NRVRIT0RTXS5tYXAoKG1ldGhvZCkgPT4gbWV0aG9kLnRvVXBwZXJDYXNlKCkpXG5cbnR5cGUgSGFuZGxlckRhdGE8VD4gPSBbVFtdLCBQYXJhbU1hcF0gfCBbUmVzdWx0PFQ+LCBudWxsXVxudHlwZSBTdGF0aWNNYXA8VD4gPSBSZWNvcmQ8c3RyaW5nLCBSZXN1bHQ8VD4+XG50eXBlIE1hdGNoZXI8VD4gPSBbUmVnRXhwLCBIYW5kbGVyRGF0YTxUPltdLCBTdGF0aWNNYXA8VD5dXG5cbmNvbnN0IGVtcHR5UGFyYW0gPSB7fVxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbmNvbnN0IG51bGxNYXRjaGVyOiBNYXRjaGVyPGFueT4gPSBbL14kLywgW10sIHt9XVxuXG5sZXQgd2lsZGNhcmRSZWdFeHBDYWNoZTogUmVjb3JkPHN0cmluZywgUmVnRXhwPiA9IHt9XG5mdW5jdGlvbiBidWlsZFdpbGRjYXJkUmVnRXhwKHBhdGg6IHN0cmluZyk6IFJlZ0V4cCB7XG4gIHJldHVybiAod2lsZGNhcmRSZWdFeHBDYWNoZVtwYXRoXSA/Pz0gbmV3IFJlZ0V4cChcbiAgICBwYXRoID09PSAnKicgPyAnJyA6IGBeJHtwYXRoLnJlcGxhY2UoL1xcL1xcKi8sICcoPzp8Ly4qKScpfSRgXG4gICkpXG59XG5cbmZ1bmN0aW9uIGNsZWFyV2lsZGNhcmRSZWdFeHBDYWNoZSgpIHtcbiAgd2lsZGNhcmRSZWdFeHBDYWNoZSA9IHt9XG59XG5cbmZ1bmN0aW9uIGJ1aWxkTWF0Y2hlckZyb21QcmVwcm9jZXNzZWRSb3V0ZXM8VD4ocm91dGVzOiBbc3RyaW5nLCBUW11dW10pOiBNYXRjaGVyPFQ+IHtcbiAgY29uc3QgdHJpZSA9IG5ldyBUcmllKClcbiAgY29uc3QgaGFuZGxlcnM6IEhhbmRsZXJEYXRhPFQ+W10gPSBbXVxuICBpZiAocm91dGVzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBudWxsTWF0Y2hlclxuICB9XG5cbiAgcm91dGVzID0gcm91dGVzLnNvcnQoKFthXSwgW2JdKSA9PiBhLmxlbmd0aCAtIGIubGVuZ3RoKVxuXG4gIGNvbnN0IHN0YXRpY01hcDogU3RhdGljTWFwPFQ+ID0ge31cbiAgZm9yIChsZXQgaSA9IDAsIGogPSAtMSwgbGVuID0gcm91dGVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgY29uc3QgcGF0aCA9IHJvdXRlc1tpXVswXVxuICAgIGxldCBwYXRoRXJyb3JDaGVja09ubHkgPSBmYWxzZVxuICAgIGlmICghL1xcKnxcXC86Ly50ZXN0KHBhdGgpKSB7XG4gICAgICBwYXRoRXJyb3JDaGVja09ubHkgPSB0cnVlXG4gICAgICBzdGF0aWNNYXBbcm91dGVzW2ldWzBdXSA9IHsgaGFuZGxlcnM6IHJvdXRlc1tpXVsxXSwgcGFyYW1zOiBlbXB0eVBhcmFtIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaisrXG4gICAgfVxuXG4gICAgbGV0IHBhcmFtTWFwXG4gICAgdHJ5IHtcbiAgICAgIHBhcmFtTWFwID0gdHJpZS5pbnNlcnQocGF0aCwgaiwgcGF0aEVycm9yQ2hlY2tPbmx5KVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHRocm93IGUgPT09IFBBVEhfRVJST1IgPyBuZXcgVW5zdXBwb3J0ZWRQYXRoRXJyb3IocGF0aCkgOiBlXG4gICAgfVxuXG4gICAgaWYgKHBhdGhFcnJvckNoZWNrT25seSkge1xuICAgICAgY29udGludWVcbiAgICB9XG5cbiAgICBoYW5kbGVyc1tqXSA9XG4gICAgICBwYXJhbU1hcC5sZW5ndGggPT09IDBcbiAgICAgICAgPyBbeyBoYW5kbGVyczogcm91dGVzW2ldWzFdLCBwYXJhbXM6IGVtcHR5UGFyYW0gfSwgbnVsbF1cbiAgICAgICAgOiBbcm91dGVzW2ldWzFdLCBwYXJhbU1hcF1cbiAgfVxuXG4gIGNvbnN0IFtyZWdleHAsIGluZGV4UmVwbGFjZW1lbnRNYXAsIHBhcmFtUmVwbGFjZW1lbnRNYXBdID0gdHJpZS5idWlsZFJlZ0V4cCgpXG4gIGZvciAobGV0IGkgPSAwLCBsZW4gPSBoYW5kbGVycy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIGNvbnN0IHBhcmFtTWFwID0gaGFuZGxlcnNbaV1bMV1cbiAgICBpZiAocGFyYW1NYXApIHtcbiAgICAgIGZvciAobGV0IGogPSAwLCBsZW4gPSBwYXJhbU1hcC5sZW5ndGg7IGogPCBsZW47IGorKykge1xuICAgICAgICBwYXJhbU1hcFtqXVsxXSA9IHBhcmFtUmVwbGFjZW1lbnRNYXBbcGFyYW1NYXBbal1bMV1dXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgY29uc3QgaGFuZGxlck1hcDogSGFuZGxlckRhdGE8VD5bXSA9IFtdXG4gIC8vIHVzaW5nIGBpbmAgYmVjYXVzZSBpbmRleFJlcGxhY2VtZW50TWFwIGlzIGEgc3BhcnNlIGFycmF5XG4gIGZvciAoY29uc3QgaSBpbiBpbmRleFJlcGxhY2VtZW50TWFwKSB7XG4gICAgaGFuZGxlck1hcFtpXSA9IGhhbmRsZXJzW2luZGV4UmVwbGFjZW1lbnRNYXBbaV1dXG4gIH1cblxuICByZXR1cm4gW3JlZ2V4cCwgaGFuZGxlck1hcCwgc3RhdGljTWFwXSBhcyBNYXRjaGVyPFQ+XG59XG5cbmZ1bmN0aW9uIGZpbmRNaWRkbGV3YXJlPFQ+KFxuICBtaWRkbGV3YXJlOiBSZWNvcmQ8c3RyaW5nLCBUW10+IHwgdW5kZWZpbmVkLFxuICBwYXRoOiBzdHJpbmdcbik6IFRbXSB8IHVuZGVmaW5lZCB7XG4gIGlmICghbWlkZGxld2FyZSkge1xuICAgIHJldHVybiB1bmRlZmluZWRcbiAgfVxuXG4gIGZvciAoY29uc3QgayBvZiBPYmplY3Qua2V5cyhtaWRkbGV3YXJlKS5zb3J0KChhLCBiKSA9PiBiLmxlbmd0aCAtIGEubGVuZ3RoKSkge1xuICAgIGlmIChidWlsZFdpbGRjYXJkUmVnRXhwKGspLnRlc3QocGF0aCkpIHtcbiAgICAgIHJldHVybiBbLi4ubWlkZGxld2FyZVtrXV1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdW5kZWZpbmVkXG59XG5cbmV4cG9ydCBjbGFzcyBSZWdFeHBSb3V0ZXI8VD4gaW1wbGVtZW50cyBSb3V0ZXI8VD4ge1xuICBtaWRkbGV3YXJlPzogUmVjb3JkPHN0cmluZywgUmVjb3JkPHN0cmluZywgVFtdPj5cbiAgcm91dGVzPzogUmVjb3JkPHN0cmluZywgUmVjb3JkPHN0cmluZywgVFtdPj5cblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLm1pZGRsZXdhcmUgPSB7IFtNRVRIT0RfTkFNRV9BTExdOiB7fSB9XG4gICAgdGhpcy5yb3V0ZXMgPSB7IFtNRVRIT0RfTkFNRV9BTExdOiB7fSB9XG4gIH1cblxuICBhZGQobWV0aG9kOiBzdHJpbmcsIHBhdGg6IHN0cmluZywgaGFuZGxlcjogVCkge1xuICAgIGNvbnN0IHsgbWlkZGxld2FyZSwgcm91dGVzIH0gPSB0aGlzXG5cbiAgICBpZiAoIW1pZGRsZXdhcmUgfHwgIXJvdXRlcykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW4gbm90IGFkZCBhIHJvdXRlIHNpbmNlIHRoZSBtYXRjaGVyIGlzIGFscmVhZHkgYnVpbHQuJylcbiAgICB9XG5cbiAgICBpZiAoIW1ldGhvZE5hbWVzLmluY2x1ZGVzKG1ldGhvZCkpIG1ldGhvZE5hbWVzLnB1c2gobWV0aG9kKVxuICAgIGlmICghbWlkZGxld2FyZVttZXRob2RdKSB7XG4gICAgICA7W21pZGRsZXdhcmUsIHJvdXRlc10uZm9yRWFjaCgoaGFuZGxlck1hcCkgPT4ge1xuICAgICAgICBoYW5kbGVyTWFwW21ldGhvZF0gPSB7fVxuICAgICAgICBPYmplY3Qua2V5cyhoYW5kbGVyTWFwW01FVEhPRF9OQU1FX0FMTF0pLmZvckVhY2goKHApID0+IHtcbiAgICAgICAgICBoYW5kbGVyTWFwW21ldGhvZF1bcF0gPSBbLi4uaGFuZGxlck1hcFtNRVRIT0RfTkFNRV9BTExdW3BdXVxuICAgICAgICB9KVxuICAgICAgfSlcbiAgICB9XG5cbiAgICBpZiAocGF0aCA9PT0gJy8qJykge1xuICAgICAgcGF0aCA9ICcqJ1xuICAgIH1cblxuICAgIGlmICgvXFwqJC8udGVzdChwYXRoKSkge1xuICAgICAgY29uc3QgcmUgPSBidWlsZFdpbGRjYXJkUmVnRXhwKHBhdGgpXG4gICAgICBpZiAobWV0aG9kID09PSBNRVRIT0RfTkFNRV9BTEwpIHtcbiAgICAgICAgT2JqZWN0LmtleXMobWlkZGxld2FyZSkuZm9yRWFjaCgobSkgPT4ge1xuICAgICAgICAgIG1pZGRsZXdhcmVbbV1bcGF0aF0gfHw9XG4gICAgICAgICAgICBmaW5kTWlkZGxld2FyZShtaWRkbGV3YXJlW21dLCBwYXRoKSB8fFxuICAgICAgICAgICAgZmluZE1pZGRsZXdhcmUobWlkZGxld2FyZVtNRVRIT0RfTkFNRV9BTExdLCBwYXRoKSB8fFxuICAgICAgICAgICAgW11cbiAgICAgICAgfSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1pZGRsZXdhcmVbbWV0aG9kXVtwYXRoXSB8fD1cbiAgICAgICAgICBmaW5kTWlkZGxld2FyZShtaWRkbGV3YXJlW21ldGhvZF0sIHBhdGgpIHx8XG4gICAgICAgICAgZmluZE1pZGRsZXdhcmUobWlkZGxld2FyZVtNRVRIT0RfTkFNRV9BTExdLCBwYXRoKSB8fFxuICAgICAgICAgIFtdXG4gICAgICB9XG4gICAgICBPYmplY3Qua2V5cyhtaWRkbGV3YXJlKS5mb3JFYWNoKChtKSA9PiB7XG4gICAgICAgIGlmIChtZXRob2QgPT09IE1FVEhPRF9OQU1FX0FMTCB8fCBtZXRob2QgPT09IG0pIHtcbiAgICAgICAgICBPYmplY3Qua2V5cyhtaWRkbGV3YXJlW21dKS5mb3JFYWNoKChwKSA9PiB7XG4gICAgICAgICAgICByZS50ZXN0KHApICYmIG1pZGRsZXdhcmVbbV1bcF0ucHVzaChoYW5kbGVyKVxuICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICAgIH0pXG5cbiAgICAgIE9iamVjdC5rZXlzKHJvdXRlcykuZm9yRWFjaCgobSkgPT4ge1xuICAgICAgICBpZiAobWV0aG9kID09PSBNRVRIT0RfTkFNRV9BTEwgfHwgbWV0aG9kID09PSBtKSB7XG4gICAgICAgICAgT2JqZWN0LmtleXMocm91dGVzW21dKS5mb3JFYWNoKChwKSA9PiByZS50ZXN0KHApICYmIHJvdXRlc1ttXVtwXS5wdXNoKGhhbmRsZXIpKVxuICAgICAgICB9XG4gICAgICB9KVxuXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBjb25zdCBwYXRocyA9IGNoZWNrT3B0aW9uYWxQYXJhbWV0ZXIocGF0aCkgfHwgW3BhdGhdXG4gICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IHBhdGhzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBjb25zdCBwYXRoID0gcGF0aHNbaV1cblxuICAgICAgT2JqZWN0LmtleXMocm91dGVzKS5mb3JFYWNoKChtKSA9PiB7XG4gICAgICAgIGlmIChtZXRob2QgPT09IE1FVEhPRF9OQU1FX0FMTCB8fCBtZXRob2QgPT09IG0pIHtcbiAgICAgICAgICByb3V0ZXNbbV1bcGF0aF0gfHw9IFtcbiAgICAgICAgICAgIC4uLihmaW5kTWlkZGxld2FyZShtaWRkbGV3YXJlW21dLCBwYXRoKSB8fFxuICAgICAgICAgICAgICBmaW5kTWlkZGxld2FyZShtaWRkbGV3YXJlW01FVEhPRF9OQU1FX0FMTF0sIHBhdGgpIHx8XG4gICAgICAgICAgICAgIFtdKSxcbiAgICAgICAgICBdXG4gICAgICAgICAgcm91dGVzW21dW3BhdGhdLnB1c2goaGFuZGxlcilcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9XG4gIH1cblxuICBtYXRjaChtZXRob2Q6IHN0cmluZywgcGF0aDogc3RyaW5nKTogUmVzdWx0PFQ+IHwgbnVsbCB7XG4gICAgY2xlYXJXaWxkY2FyZFJlZ0V4cENhY2hlKCkgLy8gbm8gbG9uZ2VyIHVzZWQuXG5cbiAgICBjb25zdCBtYXRjaGVycyA9IHRoaXMuYnVpbGRBbGxNYXRjaGVycygpXG5cbiAgICB0aGlzLm1hdGNoID0gKG1ldGhvZCwgcGF0aCkgPT4ge1xuICAgICAgY29uc3QgbWF0Y2hlciA9IG1hdGNoZXJzW21ldGhvZF1cblxuICAgICAgY29uc3Qgc3RhdGljTWF0Y2ggPSBtYXRjaGVyWzJdW3BhdGhdXG4gICAgICBpZiAoc3RhdGljTWF0Y2gpIHtcbiAgICAgICAgcmV0dXJuIHN0YXRpY01hdGNoXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IG1hdGNoID0gcGF0aC5tYXRjaChtYXRjaGVyWzBdKVxuICAgICAgaWYgKCFtYXRjaCkge1xuICAgICAgICByZXR1cm4gbnVsbFxuICAgICAgfVxuXG4gICAgICBjb25zdCBpbmRleCA9IG1hdGNoLmluZGV4T2YoJycsIDEpXG4gICAgICBjb25zdCBbaGFuZGxlcnMsIHBhcmFtTWFwXSA9IG1hdGNoZXJbMV1baW5kZXhdXG4gICAgICBpZiAoIXBhcmFtTWFwKSB7XG4gICAgICAgIHJldHVybiBoYW5kbGVyc1xuICAgICAgfVxuXG4gICAgICBjb25zdCBwYXJhbXM6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4gPSB7fVxuICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IHBhcmFtTWFwLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHBhcmFtc1twYXJhbU1hcFtpXVswXV0gPSBtYXRjaFtwYXJhbU1hcFtpXVsxXV1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHsgaGFuZGxlcnMsIHBhcmFtcyB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMubWF0Y2gobWV0aG9kLCBwYXRoKVxuICB9XG5cbiAgcHJpdmF0ZSBidWlsZEFsbE1hdGNoZXJzKCk6IFJlY29yZDxzdHJpbmcsIE1hdGNoZXI8VD4+IHtcbiAgICBjb25zdCBtYXRjaGVyczogUmVjb3JkPHN0cmluZywgTWF0Y2hlcjxUPj4gPSB7fVxuXG4gICAgbWV0aG9kTmFtZXMuZm9yRWFjaCgobWV0aG9kKSA9PiB7XG4gICAgICBtYXRjaGVyc1ttZXRob2RdID0gdGhpcy5idWlsZE1hdGNoZXIobWV0aG9kKSB8fCBtYXRjaGVyc1tNRVRIT0RfTkFNRV9BTExdXG4gICAgfSlcblxuICAgIC8vIFJlbGVhc2UgY2FjaGVcbiAgICB0aGlzLm1pZGRsZXdhcmUgPSB0aGlzLnJvdXRlcyA9IHVuZGVmaW5lZFxuXG4gICAgcmV0dXJuIG1hdGNoZXJzXG4gIH1cblxuICBwcml2YXRlIGJ1aWxkTWF0Y2hlcihtZXRob2Q6IHN0cmluZyk6IE1hdGNoZXI8VD4gfCBudWxsIHtcbiAgICBjb25zdCByb3V0ZXM6IFtzdHJpbmcsIFRbXV1bXSA9IFtdXG5cbiAgICBsZXQgaGFzT3duUm91dGUgPSBtZXRob2QgPT09IE1FVEhPRF9OQU1FX0FMTFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tbm9uLW51bGwtYXNzZXJ0aW9uXG4gICAgO1t0aGlzLm1pZGRsZXdhcmUhLCB0aGlzLnJvdXRlcyFdLmZvckVhY2goKHIpID0+IHtcbiAgICAgIGNvbnN0IG93blJvdXRlID0gclttZXRob2RdXG4gICAgICAgID8gT2JqZWN0LmtleXMoclttZXRob2RdKS5tYXAoKHBhdGgpID0+IFtwYXRoLCByW21ldGhvZF1bcGF0aF1dKVxuICAgICAgICA6IFtdXG4gICAgICBpZiAob3duUm91dGUubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgIGhhc093blJvdXRlIHx8PSB0cnVlXG4gICAgICAgIHJvdXRlcy5wdXNoKC4uLihvd25Sb3V0ZSBhcyBbc3RyaW5nLCBUW11dW10pKVxuICAgICAgfSBlbHNlIGlmIChtZXRob2QgIT09IE1FVEhPRF9OQU1FX0FMTCkge1xuICAgICAgICByb3V0ZXMucHVzaChcbiAgICAgICAgICAuLi4oT2JqZWN0LmtleXMocltNRVRIT0RfTkFNRV9BTExdKS5tYXAoKHBhdGgpID0+IFtwYXRoLCByW01FVEhPRF9OQU1FX0FMTF1bcGF0aF1dKSBhcyBbXG4gICAgICAgICAgICBzdHJpbmcsXG4gICAgICAgICAgICBUW11cbiAgICAgICAgICBdW10pXG4gICAgICAgIClcbiAgICAgIH1cbiAgICB9KVxuXG4gICAgaWYgKCFoYXNPd25Sb3V0ZSkge1xuICAgICAgcmV0dXJuIG51bGxcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGJ1aWxkTWF0Y2hlckZyb21QcmVwcm9jZXNzZWRSb3V0ZXMocm91dGVzKVxuICAgIH1cbiAgfVxufVxuIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLG9EQUFvRCxHQUNwRCxBQUNBLFNBQVMsZUFBZSxFQUFFLE9BQU8sRUFBRSxvQkFBb0IsUUFBUSxrQkFBaUI7QUFDaEYsU0FBUyxzQkFBc0IsUUFBUSxxQkFBb0I7QUFDM0QsU0FBUyxVQUFVLFFBQVEsWUFBVztBQUV0QyxTQUFTLElBQUksUUFBUSxZQUFXO0FBRWhDLE1BQU0sY0FBYztJQUFDO09BQW9CO0NBQVEsQ0FBQyxHQUFHLENBQUMsQ0FBQyxTQUFXLE9BQU8sV0FBVztBQU1wRixNQUFNLGFBQWEsQ0FBQztBQUNwQiw4REFBOEQ7QUFDOUQsTUFBTSxjQUE0QjtJQUFDO0lBQU0sRUFBRTtJQUFFLENBQUM7Q0FBRTtBQUVo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